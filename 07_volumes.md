## Working with Volumes

At the end of this lesson, you will be able to:
* Create containers holding volumes.
* Share volumes across containers.
* Share a host directory with one or many containers.


----

### Working with Volumes
Docker volumes can be used:
* Bypassing the copy-on-write system to obtain native disk I/O performance.
* Bypassing copy-on-write to leave some files out of docker commit.
* Sharing a directory between multiple containers.
* Sharing a directory between the host and a container.
* Sharing a single file between the host and a container

----

### Volumes in containers
Volumes are special directories in a container
Volumes can be declared in two different ways.
* Within a Dockerfile, with a VOLUME instruction.  
```
VOLUME /var/lib/postgresql
```
* On the command-line, with the -v flag for docker run.
```
docker run -d -v /var/lib/postgresql \ training/postgresql
```
In both cases, /var/lib/postgresql (inside the container) will be a volume.

----

### Volumes bypass the copy-on-write system
Volumes act as passthroughs to the host filesystem.
* The I/O performance on a volume is exactly the same as I/O performance on the Docker host.
* When you `docker commit`, the content of volumes is not brought into the resulting image.
* If a `RUN` instruction in a Dockerfile changes the content of a volume, those changes are not recorded neither.

----

### Volumes can be shared across containers
* You can start a container with exactly the same volumes as another one.
* The new container will have the same volumes, in the same directories.
* They will contain exactly the same thing, and remain in sync.
* Under the hood, they are actually the same directories on the host anyway.

----

### Volumes can be shared across containers

This is done using the --volumes-from flag for docker run.
```bash
docker run -ti --name alpha -v /var/log ubuntu bash
date > /var/log/now
```
Detach from that container `^p^q` and start another container with the same volume.
```bash
docker run --volumes-from alpha ubuntu cat /var/log/now
Tue Aug 16 14:16:46 UTC 2016
```

----

### Volumes exist independently of containers
If a container is stopped, its volumes still exist and are available.
In the example before, it doesn't matter if container alpha is running or not.
Since Docker 1.9, we can see all existing volumes and manipulate them:
```bash
docker volume ls
DRIVER              VOLUME NAME
local               045e85912e993e65cd00ebd4d39df8243c7baa064472d6297701746a41927807
local               06ea6a799cee6f79a09a85d5e65b996ffe594427cc1faf60f8908a2c76632d31
local               0bb70368633f3043f26732a0ce5fcb4f63f40be826fe2a072e51277636d36766
...
```

----

Some volumes are explicitly named like:
```bash
local               files
local               https
local               logs
local               registry-stuff
```
The other are the HEX autogenerated IDs

----

### Data containers (before 1.9)
A data container is a container created for the sole purpose of referencing one (or many) volumes.  
It is typically created with a no-op command:
```bash
docker run --name files -v /var/www busybox true
docker run --name logs -v /var/log busybox true
```
* Two data containers get created
* Using the busybox image
* We used the command true
* Each container is named to reference them easily later

----

### Using data containers
Data containers are used by other containers thanks to --volumes-from.  
Consider the following (fictitious) example, using the previously created volumes:
```bash
docker run -d --volumes-from files --volumes-from logs webserver
docker run -d --volumes-from files ftpserver
docker run -d --volumes-from logs lumberjack
```
* The first container runs a webserver, serving content from /var/www and logging to /var/log.
* The second container runs a FTP server, allowing to upload content to the same /var/www path.
* The third container collects the logs, and sends them to logstash.


----

### Named volumes

* We can create and manipulate volumes as first-class concepts.
* Volumes can be created without a container, then used in multiple containers.

Let's create volumes directly (without data containers).
```bash
docker volume create --name=files
docker volume create --name=logs
```

Volumes are not anchored to a specific path.

----

### Using named volumes
Volumes are used with the -v option.  
When a host path does not contain a /, it is considered to be a volume name.   
Let's start the same containers as before:
```bash
docker run -d -v files:/var/www -v logs:/var/log webserver 
docker run -d -v files:/home/ftp ftpserver 
docker run -d -v logs:/var/log lumberjack
```

----

### Managing volumes
In some cases, you want a specific directory on the host to be mapped inside the container:
* You want to manage storage and snapshots yourself.  
(With LVM, or a SAN, or ZFS, or anything else!)
* You have a separate disk with better performance (SSD) or resiliency
(EBS) than the system disk, and you want to put important data on that disk.
* You want to share your source directory between your host (where the source gets edited) and the container (where it is compiled or executed).

----

### Sharing a directory between the host and a container

The previous example would become something like this:
```bash
mkdir -p /mnt/files /mnt/logs
docker run -d -v /mnt/files:/var/www -v /mnt/logs:/var/log webserver
docker run -d -v /mnt/files:/home/ftp ftpserver
docker run -d -v /mnt/logs:/var/log lunmberjack
```
Note that the paths must be absolute.
Those volumes can also be shared with --volumes-from

----

### What happens when you remove containers with volumes?
* Before Version 1.9, volumes would be orphaned when the last container referencing them is destroyed.
* Orphaned volumes are not deleted, but you cannot access them. (Unless you do some serious archeology in /var/lib/docker.)
* Since Engine 1.9, orphaned volumes can be listed with docker volume ls and mounted to containers with -v.  
Ultimately, you are the one responsible for logging, monitoring, and backup of your volumes.

----

### Find out which volume a container uses
Using the "well" known `docker inspect`

```bash
docker inspect --format '{{ json .Config.Volumes }}' alpha
{"/var/log":{}}
```

----

### Sharing a single file between the host and a container

The same -v flag can be used to share a single file.  
One of the most interesting examples is to share the Docker control socket.
```bash
docker run -it -v /var/run/docker.sock:/var/run/docker.sock docker sh
```

Warning: when using such mounts, the container gains root-like access to the host. It can potentially do bad things.

----

### Do it yourself (theoretical) Migrating data with --volumes-from

Scenario: migrating from Redis 2.8 to Redis 3.0.
* We have a container (myredis) running Redis 2.8.
* Stop the myredis container.
* Start a new container, using the Redis 3.0 image, and the --volumes-from option.
* The new container will inherit the data of the old one.
* Newer containers can use --volumes-from too.

----

### Do it yourself
Start a `php:7.0-apache` container and share a file into the container
* Run a php:7.0-apache container
* Expose the webserver port 80 to the host
* Share a php-file in with the container
* access the webserver e.g.: `curl -i http://0.0.0.0:8080:hello.php`

```php
<?php
    Print "Hello, World!";
?>
````

----

### Possible solution
```bash
docker run -dtiP -v $(PWD)/hello.php:/var/www/html/hello.php php:7.0-apache
```
Hint: That's the first step in a development workflow (local)

----

### Summary
We've learned how to:
* Create and manage volumes.
* Share volumes across containers.
* Share a host directory with one or many containers